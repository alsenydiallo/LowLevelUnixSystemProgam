#define _POSIX_SOURCE

#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>         // for fork()
#include <sys/types.h>      // for pid_t
#include <sys/wait.h>       // for waitpid()
#include <assert.h>
#include <string.h>
#include <errno.h>
#include <ctype.h>
#include <math.h>

char message[512];
int fd[2]; 			/* pipe file descriptor */
int delay = 5;		/* default value : 5 second */
int rdr, wtr; 		/* fd[0] and fd[1] */
char buffer[512];
int pid;

void printMessage(){
	printf("%s", message);
}

void my_sleep(){
	signal(SIGALRM, printMessage);
	alarm(delay);
	pause();
	alarm(0);
}

void parent_handler(){
	fprintf(stdout, "Enter a message: \n");
	fgets(buffer, 512, stdin);
}

int indexMsg(char str[]){
	int i = 0;
	while(isdigit(str[i]) || isspace(str[i]))
			++i;
	return i;
}
void child_handler(){
	char msg[512];
	msg[511] = '\0';
	read(fd[0], msg, 512);

	if(sscanf(&msg[0], "%i", &delay) == 1){
		int index = indexMsg(msg);
		strcpy(&message[0], &msg[index]);
	}else{
		strcpy(&message[0], &msg[0]);
	}
	message[511] = '\0';
}

int main(int argc, char *argv[]){

	if(pipe(fd) < 0) {fprintf(stderr, "Piping failled\n"); exit(1);}

	pid = fork();
	if (pid < 0){
			printf("fork error %d\n", pid);
	}
	else if(pid != 0){
		// parent process
		//close(fd[0]);	
		while(1){
			signal(SIGINT, parent_handler);
			pause();

		 	if(strcmp(buffer, "exit\n") == 0){
				printf("Child is diying\n");
				kill(pid, SIGKILL);
				wait(NULL);
				return 0;
			}else{
				write(fd[1], buffer, 512);
				kill(pid, SIGFPE);
			}
		}
		//close(wtr);
	}
	else{
		// child process
		//close(wtr);
		signal(SIGINT, SIG_IGN);
		int flag = 1;
		while(flag == 1){
			signal(SIGFPE, child_handler);
			my_sleep();
		}
		//close(rdr);
	}
	return 0;
}
